====== Semestrální práce ======

===== Zadání celkově =====

Vytvořte překladač z jazyka Mila do jazyka architektury virtuálního počítače Tiny Machine (viz take [[http://www.cs.sjsu.edu/~louden/cmptext/|překladač ke knize Compiler Construction]]).

Vstupem Vašeho programu ze standardniho vstupu bude zdrojový kód v jazyce Mila.

Výstupem Vašeho programu na standardní výstup bude kód programu v asembleru pro Tiny Machine, který půjde spustit v interpreteru ''tm.c'', uloženém v balíku s podklady pro semestrálku.

Níže v textu jsou specifikovány podrobnosti tří konkrétních zadání, které zahrnují překlad používající optimalizace, výběr cílových instrukcí a/nebo efektivní přidělování registrů. Každý ze studentů si vybere jedno z těchto zadání podle svého uvážení a zájmu. Zároveň u jednotlivých zadání je specifikován způsob hodnocení výsledné práce s maximálními počty bodů.  

Pro vypracování semestrální práce doporučujeme využít a případně podle sebe modifikovat již existující front-end překladače Mila, viz balík s podklady pro semestrálku.
Tento front-end již obsahuje optimalizaci výpočtu konstantních výrazů.

Termíny pro odevzdání práce jsou následující:

  * do 3.6.2011 (student může za semestrálku získat plný počet bodů)

  * od 4.6.2011 do konce zkouškového (bude uplatněna penalizace odečtem 50 procent ze získaných bodů) 
 

Do 1.5.2011 každý ze studentů oznámí emailem přednášejícímu nebo cvičícímu, které ze 3 zadání si vybral.


Dále na této stránce naleznete popis jednotlivých zadáni, soubory ke stažení a popis architektury Tiny Machine.


===== Přehled jednotlivých zadání a bodového hodnocení =====

Překladač vytváří korektní cílový kód z pohledu funkčnosti a používá optimalizaci výpočtu numerických konstantních výrazu (constant folding) (pozn. tato optimalizace je již implementována v dodaném front endu jazyka Mila) -  max. 10 b.  

**Jednotlivá zadání:**

1.  
  * Optimalizujte společné podvýrazy v rámci jednoho výrazu -   max. 10 b.
  * Optimalizujte používání cyklů přesunutím invariantů mimo tělo cyklu -  max. 10 b. 
2. 
  * Optimalizujte používání registrů tak, aby dostupné registry byly maximálně využity, v rámci celého programu - max. 20b.
  * Případně (pokud by se Vam zadání předchozí věty zdálo obtížné), optimalizujte používání registrů tak, aby dostupné registry byly maximálně využity, v rámci výrazů - max. 10b.
3.
  * Implementujte výběr instrukcí Graham-Glanvillovou technikou nebo pomocí vyhledávání vzorků a dynamického programování (uvažujte následující ceny instrukcí: cena instrukce bez přístupu do hlavní paměti (tj. používající pouze registry, RA a RM instrukce) bude 1, ceny instrukce s přístupem do hlavní paměti (RM instrukce) bude 2) - max. 20 b. 

  


===== Soubory ke stažení =====
  * {{:semestral_work:gen-semestralka.zip|Zdrojové kódy torza semestrálky}} - obsahuje kompletní překladač jazyka Mila a interpreter Tiny Machine (POZOR: interpreter je modifikovaný oproti originálu o novou instrukci)
  * {{:semestral_work:gen-semestralka.tar.gz|Nové zdrojové kódy torza semestrálky}} - obsahuje kompletní překladač jazyka Mila a interpreter Tiny Machine (POZOR: interpreter je modifikovaný oproti originálu o novou instrukci)
  * {{:semestral_work:gen-mila.pdf|Popis syntaxe jazyka Mila}} (převzato z X36PJP)



===== Popis architektury Tiny Machine  =====

Snadný přehled o architektuře dostaneme pohledem do zdrojového kódu interpreteru v souboru ''tm.c''

Jedná se o RISC s defaultně 8 registry (0-7). Má oddělenou paměť pro instrukce a data. Jejich velikosti lze definovat makrem ve zdrojovém kódu interpreteru a obě jsou standardně velké 1024 slov.

Poslední registr (7) se používá jako Program Counter (PC) a lze jej modifikovat přímo registrovými instrukcemi (lze tak realizovat nepodmíněný skok).

==== Instrukční set ====

Instrukce jsou trojího druhu

  * Registr-registr instrukce (RR)
  * Registr-paměť (RM)
  * Registr-adresa (RA)


^ Op.znak ^ význam ^^
| **RR instrukce, zapisují se ve formátu například ADD r,s,t** |||
| HALT | zastavení programu | operandy jsou ignorovány |
| IN   | čtení vstupu | čtení do ''<nowiki>reg(r)</nowiki>'', ostatní jsou ignorovány |
| OUT  | výstup   | výpis hodnoty z ''<nowiki>reg(r)</nowiki>'', ostatní jsou ignorovány |
| ADD  | sčítání  | ''<nowiki>reg(r) = reg(s) + reg(t)</nowiki>'' |
| INC((Pozor, nenachází se v originální verzi interpreteru, je potřeba použít interpreter z našeho balíku)) | inkrementace o 1  | ''<nowiki>reg(r) = reg(r) + 1</nowiki>'', ostatní jsou ignorovány |
| SUB  | odčítání | ''<nowiki>reg(r) = reg(s) - reg(t)</nowiki>'' |
| MUL  | násobení | ''<nowiki>reg(r) = reg(s) * reg(t)</nowiki>'' |
| DIV  | dělení   | ''<nowiki>reg(r) = reg(s) / reg(t)</nowiki>'' |
| **RM instrukce, zapisují se ve formátu např LD r,d(s)** |||
| LD | čtení z paměti  | ''<nowiki>reg(r) = mem(d + reg(s))</nowiki>'' | 
| ST | zápis do paměti | ''<nowiki>mem(d + reg(s)) = reg(r)</nowiki>'' |
| **RA instrukce, opět ve formátu LDA r,d(s)** |||
| LDA  | zápis adresy v paměti (pointeru) do registru | ''<nowiki>reg(r) = d+reg(s)</nowiki>''  |
| LDC  | zápis konstanty do registru | ''<nowiki>reg(r) = d</nowiki>'', ''reg(s)'' je ignorován |
| JLT  | podmíněný skok | ''<nowiki>if reg(r)<0 then reg(7) = d + reg(s)</nowiki>'' |
| JLE  | podmíněný skok | ''<nowiki>if reg(r)<=0 then reg(7) = d + reg(s)</nowiki>'' |
| JGT  | podmíněný skok | ''<nowiki>if reg(r)>0 then reg(7) = d + reg(s)</nowiki>''  |
| JGE  | podmíněný skok | ''<nowiki>if reg(r)>=0 then reg(7) = d + reg(s)</nowiki>'' |
| JEQ  | podmíněný skok | ''<nowiki>if reg(r)==0 then reg(7) = d + reg(s)</nowiki>'' |
| JNE  | podmíněný skok | ''<nowiki>if reg(r)!=0 then reg(7) = d + reg(s)</nowiki>'' |


==== Práce s pamětí ====
Na začátku běhu programu je datová paměť prázdná, kromě pozice 0, kde je uložena její délka, kterou si program může přečíst.

Proto na začátku ukázkového přeloženého programu vidíme kód
<code>
  0:     LD  6,0(0) 
  1:     ST  0,0(0) 
</code>

Překladač jazyka Tiny si tu poznamenává velikost hlavní paměti do registru 6. To se bude hodit i nám a to k následujícímu:

Hlavní paměť potřebujeme ke dvěma účelům:
  - uložení deklarovaných proměnných. 
  - uložení pomocných proměnných např. při výpočtu složitých výrazů

Deklarované proměnné můžeme ukládat na paměťová místa od začátku paměti. Jelikož se v paměťových operacích uvádí bázický registr (ten v závorce), jehož hodnota se doplňuje přímo zapsaným offsetem, musíme si tento počátek někam napsat, např. do registru číslo 5. Umístění v paměti vůči tomuto offsetu (tj, argument ''d'' LD/ST instrukce) pak získáme při překladu z tabulky symbolů. Jelikož procesor adresuje po slovech, pozice v paměti inkrementujeme s každou proměnnou o 1.

Pomocné proměnné se nám hodí pro výpočet složitých aritmetických nebo logických výrazů. Jelikož máme omezený počet registrů, ne vždy se nám povede výpočet vměstnat do registrů. Pro počet registrů potřebných k výpočtu výrazu existuje rekurentní pravidlo, které nás zajímá jen u binárních operací (závorky jsou jen prosté kopírování):

  - K načtení číselné hodnoty z konstanty/proměnné potřebujeme 1 registr
  - U binárního výrazu potřebujeme:
    - Maximum z počtu registrů potřebných pro výpočet jednoho z podvýrazů, pokud se tento počet liší (nejprve spočteme složitější výraz, výsledek necháme v jednom z registrů, zbývajících ''n-1'' registrů můžeme použít pro výpočet toho jednoduššího).
    - ''n+1'' registr pro výraz, který má oba podvýrazy stejně složité, tj. je potřeba pro každý ''n'' registrů. Pak si výsledek jednoho podvýrazu necháme v registru a dalších ''n'' potřebujeme na výpočet druhého.

Pokud nám registry nestačí, musíme používat pomocnou paměť. Pozn. profesor Louden to ve svém překladači, (viz take [[http://www.cs.sjsu.edu/~louden/cmptext/|překladač ke knize Compiler Construction]]), provádí uložením výsledku levého podstromu na zásobník, výpočtem pravého podstromu a vyzvednutí výsledku levého podstromu ze zásobníku. Ovšem dělá to i pro triviální případy, např. ''a + b'', kde bychom si vystačili s registry.
Zásobník na pomocné proměnné lze alokovat od konce paměti, k tomu slouží onen registr 6 a záporné offsety. Tj. dočasné proměnné mají umístění ''-1(6)'', ''-2(6)''. Všimněte si, že ve vzorovém příkladu si program načetl délku paměti do tohoto registru. Alokaci paměťových míst samozřejmě provádí již překladač.


==== Formát kódu programu pro Tiny Machine (výstup vaší semestrálky) ====


Soubor má formát paměťového image, před samotnou interpretací se nahraje do instrukční paměti celý. To dovoluje generovat řádky strojového kódu do souboru na přeskáčku. Lze tak efektivně generovat skoky v podmíněných blocích a cyklech, u kterých neznáme délku skoku. Vynecháme si na instrukci místo, a v momentě, kdy známe délku skoku, tuto instrukci zapíšeme na současné místo v souboru, nicméně s adresou odpovídající správnému umístění. Viz například instrukce na adrese 13 ve vzorovém příkladu překladače.


Výstup vaší semestrálky bude v následujícím formátu:
<code>
  0:     LD  6,0(0) 
  1:     ST  0,0(0) 
  2:     IN  0,0,0 
  3:     ST  0,0(5) 
  4:    LDC  0,0(0) 
  5:     ST  0,0(6) 
  6:     LD  0,0(5) 
...
</code>
Číslo před dvojtečkou znamená umístění v paměti. Nedefinované pozice jsou automaticky prázdné a vyhodnoceny jako HALT.

Řádky začínající symbolem hvězdičky (*) značí komentáře.

~~DISCUSSION~~